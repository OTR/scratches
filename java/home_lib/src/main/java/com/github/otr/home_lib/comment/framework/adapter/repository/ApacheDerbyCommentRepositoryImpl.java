package com.github.otr.home_lib.comment.framework.adapter.repository;

import com.github.otr.home_lib.comment.domain.entity.Comment;
import com.github.otr.home_lib.comment.domain.repository.CommentRepository;
import com.github.otr.home_lib.exception.RepositoryException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import java.sql.Statement;
import java.sql.Timestamp;

import java.time.LocalDateTime;

import java.util.ArrayList;
import java.util.List;

/**
 *
 */
@Deprecated(since = "Derby sucks")
public class ApacheDerbyCommentRepositoryImpl implements CommentRepository {

    private static final Logger LOGGER = LoggerFactory.getLogger(
            ApacheDerbyCommentRepositoryImpl.class
    );
    private static final String DEFAULT_DB_URL = "jdbc:derby:.app_data/comments.db;create=true";
    private static final String INSERT_STATEMENT = "INSERT INTO comments (created, text) VALUES (?, ?)";
    private static final String SELECT_LAST_10_STATEMENT = "SELECT * FROM comments ORDER BY id DESC FETCH FIRST 10 ROWS ONLY";
    private static final String SELECT_ALL_STATEMENT = "SELECT * FROM comments";
    public static final String SELECT_TABLE_WITH_NAME_COMMENTS = "SELECT COUNT(*) FROM SYS.SYSTABLES WHERE TABLENAME = 'COMMENTS'";

    private static final String CREATE_TABLE_STATEMENT = ("CREATE TABLE comments (\n" +
                                                          "    id INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1), \n" +
                                                          "    created TIMESTAMP NOT NULL, \n" +
                                                          "    text VARCHAR(255), \n" +
                                                          "    PRIMARY KEY (id)\n" +
                                                          ")");
    private static final int FIRST_PARAM = 1;
    private static final int SECOND_PARAM = 2;
    private static final int EXACTLY_ONE = 1;
    private static final int FIRST_COLUMN = 1;

    private final String dbUrl;

    public ApacheDerbyCommentRepositoryImpl() {
        this.dbUrl = DEFAULT_DB_URL;
        createSchemaIfNeeded();
    }

    public ApacheDerbyCommentRepositoryImpl(String dbUrl) {
        this.dbUrl = dbUrl == null ? DEFAULT_DB_URL : dbUrl;
        createSchemaIfNeeded();
    }

    private void createSchemaIfNeeded() {
        Connection conn = null;
        try {
            conn = DriverManager.getConnection(dbUrl);
            Statement statement = conn.createStatement();
            ResultSet rs = statement.executeQuery(SELECT_TABLE_WITH_NAME_COMMENTS);
            rs.next();
            int tablesCount = rs.getInt(FIRST_COLUMN);
            if (tablesCount == 0) {
                PreparedStatement createStatement = conn.prepareStatement(
                        CREATE_TABLE_STATEMENT
                );
                createStatement.execute();
            }
        } catch (SQLException e) {
            throw new RepositoryException(
                    "Failed to create database schema", e
            );
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    LOGGER.error("Failed to close connection", e);
                }
            }
        }
    }

    @Override
    public boolean createComment(Comment comment) {
        try (Connection conn = DriverManager.getConnection(DEFAULT_DB_URL)) {
            // TODO: Sanitize from SQL Injection
            PreparedStatement statement = conn.prepareStatement(INSERT_STATEMENT);
            Timestamp createdTimestamp = Timestamp.valueOf(comment.created());
            // The id field is omitted from the INSERT statement
            // as it's auto-generated by the database.
            statement.setTimestamp(FIRST_PARAM, createdTimestamp);
            statement.setString(SECOND_PARAM, comment.text());
            int rowUpdated = statement.executeUpdate();
            return EXACTLY_ONE == rowUpdated;
        } catch (SQLException e) {
            // TODO: Replace the logger implementation with notification service
            LOGGER.error("Failed to INSERT a new Comment");
            throw new RepositoryException("Failed to INSERT a new Comment", e);
        }
    }

    @Override
    public List<Comment> getAllComments() {
        List<Comment> comments = new ArrayList<>();
        Connection conn = null;
        try {
            conn = DriverManager.getConnection(dbUrl);
            PreparedStatement stmt = conn.prepareStatement(SELECT_ALL_STATEMENT);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                int id = rs.getInt("id");
                LocalDateTime created = rs.getTimestamp("created").toLocalDateTime();
                String text = rs.getString("text");
                Comment comment = new Comment(id, created, text);
                comments.add(comment);
            }
        } catch (SQLException e) {
            throw new RepositoryException("Failed to SELECT ALL comments", e);
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    LOGGER.error("Failed to close connection", e);
                }
            }
        }
        return comments;
    }

    @Override
    public List<Comment> getLast10Comments() {
        List<Comment> comments = new ArrayList<>();
        try (Connection conn = DriverManager.getConnection(DEFAULT_DB_URL);) {
            PreparedStatement stmt = conn.prepareStatement(SELECT_LAST_10_STATEMENT);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                int id = rs.getInt("id");
                LocalDateTime created = rs.getTimestamp("created").toLocalDateTime();
                String text = rs.getString("text");
                Comment comment = new Comment(id, created, text);
                comments.add(comment);
            }
        } catch (SQLException e) {
            throw new RepositoryException("Failed to SELECT last 10 comments", e);
        }

        return comments;
    }

}
